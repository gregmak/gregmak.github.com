{"name":"Gregmak.github.com","body":"Travaillant chez **MLstate**, la compagnie ayant développé le framework JavaScript **Opa**, j'ai trouvé intéressant de présenter quelques tutoriels et comparatifs avec d'autres frameworks JS.\r\n\r\nLe but de ces tutoriels est de montrer comment **Opa** peut s'avérer un framework JS aussi puissant que d'autres (tels que **Express.js** ou **Backbone.js**) et comprenant de nombreux avantages que les autres n'ont pas forcément (tels que le typage static).\r\n\r\n## Création d'un web-service **RESTful**.\r\n\r\nLe premier de ces tutoriels portera sur la gestion en **Opa** des requêtes HTTP de type **REST** et permettra de comparer **Opa** avec **Express.js**, framework facilitant le développement de services **RESTful** en JavaScript.\r\n\r\nPour ce faire, nous allons écrire une petite application permettant de traiter des requêtes **REST** telles que **POST**, **PUT**, **DELETE** et **GET** et de manipuler des ressources en conséquence.\r\nCette application est inspirée de celle développée par **k33g_org** et dont vous pouvez voir le tutoriel à l'adresse http://k33g.github.com/2012/02/19/EXPRESSJS_IS_PLAY.html.\r\n\r\n#### Pre-requis.\r\n\r\nVous devez bien sûr installer **Opa**, téléchargeable directement depuis le site d'[opalang](opalang.org), ou depuis le [repo github d'opalang](https://github.com/MLstate/opalang).\r\n\r\nUns fois **Opa** téléchargé et installé, vous devriez avoir tout ce dont vous avez besoin. Il n'y a pas d'autres dépendances à installer (**Node.js** étant automatiquement installé par **Opa** s'il n'est pas détecté durant la phase de configuration).\r\n\r\n#### Le squelette de l'application.\r\n\r\n**Opa** est livré avec un outil permettant de générer un squelette d'application basé sur le modèle **MVC**.\r\n\r\nOuvrez une console, placez vous à l'endroit souhaité et tappez simplement\r\n\r\n```opa create snippets```\r\n\r\noù *snippets* est le nom de notre application.\r\n\r\nCela va créer un repertoire *snippets* comprenant le squelette de notre application (pour plus de détails sur cet outil, regardez [l'article de Cédric Soulas sur le blog d'opalang](http://blog.opalang.org/2012/06/programming-tools-ux-how-we-simplified.html)).\r\n\r\n#### La configuration.\r\n\r\nUn fichier nommé ```opa.conf``` est placé à la racine de l'application et décrit les importations nécessaires pour chaque fichier, que ce soit l'importation d'éléments de la librairie standard d'**Opa** ou d'un des autres fichiers source de l'application. Éditez ce fichier et modifier-le comme ceci :\r\n\r\n```\r\nsnippets.controller:\r\n\timport snippets.view\r\n\timport snippets.model // nouvelle ligne ajoutée\r\n\tsrc/controller.opa\r\n\r\nsnippets.view:\r\n\timport snippets.model\r\n\timport stdlib.themes.bootstrap\r\n\tsrc/view.opa\r\n\r\nsnippets.model:\r\n\tsrc/model.opa\r\n```\r\n\r\nEn ajoutant la ligne ```import snippets.model```, nous avons indiqué au compilateur que le module **Controller** définit dans le fichier ```src/controller.opa``` a besoin de connaître certaines fonctions définies dans le module **Model** définit dans le fichier ```src/model.opa```.\r\n\r\nNotez que ces déclarations peuvent aussi bien se faire en début de chaque fichier. Mais l'utilisation d'un fichier ```opa.conf``` a l'avantage de centraliser toutes les déclarations de ce type.\r\n\r\n#### Le modèle.\r\n\r\nUne fois le squelette créé, nous commençons par modifier le fichier ```src/model.opa``` pour y inclure la définition d'un *snippet* et les traitements associés.\r\n\r\n```\r\ntype Snippet.t =\r\n    {option(int) id, string title, string code, string user}\r\n\r\nmodule Snippet {\r\n\r\n    // user context pour gérer la persistance en mémoire\r\n    UserContext.t(list(Snippet.t)) snippets = UserContext.make([]);\r\n\r\n    function make_snippet(title, code, user) {\r\n\t{id: {none}, ~title, ~code, ~user}\r\n    }\r\n\r\n    function save_snippet(snippet, callback) {\r\n\tmatch (snippet.id) {\r\n\tcase {some : id}: // le snippet existe\r\n\t    UserContext.change((function(snippets) {\r\n\t\tsnippets = List.remove_p((function(snippet) {snippet.id == {some: id}}), snippets);\r\n\t\tList.cons(snippet, snippets);\r\n\t    }), snippets);\r\n\t    // on applique le callback sur le snippet donné\r\n\t    callback(snippet);\r\n\tdefault: // nouveau snippet\r\n\t    l = UserContext.execute((function(snippets) {List.length(snippets)}), snippets);\r\n\t    // on met à jour l'id du snippet\r\n\t    id = if (l >= 5) {some : 1} else {some : l + 1}\r\n\t    snippet = {snippet with ~id}\r\n\t    UserContext.change((function(snippets) {\r\n\t\t// on réinitialise tous les 5 snippets\r\n\t\tif (l >= 5) {\r\n\t\t    [snippet]\r\n\t\t}\r\n\t\telse {\r\n\t\t    List.cons(snippet, snippets)\r\n\t\t}\r\n\t    }), snippets);\r\n\t    // on applique le callback sur le snippet modifié\r\n\t    callback(snippet);\r\n\t};\r\n    }\r\n\r\n    function delete_snippet(id, callback) {\r\n\tmatch (find_by_id(id)) {\r\n\tcase {some: snippet} :\r\n\t    UserContext.change((function(snippets) {\r\n\t\tList.remove_p((function(snippet) {snippet.id == id}), snippets);\r\n\t    }), snippets);\r\n\t    // on applique le callback sur le snippet trouvé\r\n\t    callback(snippet);\r\n\tdefault : Resource.source(\"ERROR : SNIPPET NOT FOUND\", \"application/json\");\r\n\t}\r\n    }\r\n\r\n    function find_all(callback) {\r\n\tUserContext.execute((function(snippets) {\r\n\t    callback(snippets);\r\n\t}), snippets);\r\n    }\r\n\r\n    function find_by_id(id) {\r\n\tUserContext.execute((function(snippets) {\r\n\t    List.find((function(snippet) {snippet.id == id}), snippets);\r\n\t}), snippets);\r\n    }\r\n\r\n}\r\n```\r\n\r\nCe fichier ne présente pas de grandes difficultés si vous êtes familiers avec **Opa** et la programmation fonctionnelle.\r\n\r\nLa seule particularité est l'utilisation du **UserContext**. Ce module appartenant à la librairie standard d'**Opa** est un des moyens offerts par **Opa** permettant la création et la manipulation d'éléments mutables.\r\n\r\n#### La vue.\r\n\r\nNous allons maintenant éditer le ficher ```src/view.opa``` pour définir la structure de la page.\r\n\r\n```\r\nmodule View {\r\n\r\n    function initialize() {\r\n\tsnippet_one = Model.make_snippet(\"essai 1\",\"//FOO\",\"gregmak\");\r\n\tsnippet_two = Model.make_snippet(\"essai 2\",\"//Hello World\",\"gregmak\");\r\n\tsnippet_three = Model.make_snippet(\"essai 3\",\"//Me again !\",\"gregmak\");\r\n\r\n\tfunction foo(snippet) {\r\n\t    jlog(snippet.title);\r\n\t};\r\n\r\n\tModel.save_snippet(snippet_one, foo);\r\n\tModel.save_snippet(snippet_two, foo);\r\n\tModel.save_snippet(snippet_three, foo);\r\n    }\r\n\r\n  function simple_main_page() {\r\n      content =\r\n\t<div>\r\n\t<h2 onready={function(_) {initialize()}}>\"Opa VS Express.js\"</h2>\r\n\t</div>;\r\n    Resource.page(\"Hello\", content)\r\n}\r\n```\r\nNotez ici que vous pouvez écrire directement du code HTML dans du code **Opa**. La création de pages web en **Opa** n'etant pas le sujet de ce tutoriel, nous nous contenterons d'une simple page vierge suffisante au bon déroulement de notre application.\r\n\r\n#### Le contrôleur.\r\n\r\nIl nous reste maintenant à gérer la définition du serveur, le dispatcheur (ou routeur) et le traitements des requêtes **REST**.\r\nCela se fait dans le fichier ```src/controller.opa```, que nous allons éditer et modifier comme cela :\r\n\r\n```\r\n   function snippet_to_string(snippet) {\r\n    \t\"\\{\\\"id\\\": {Option.default((-1), snippet.id)}, \\\"title\\\": \\\"{snippet.title}\\\", \\\"code\\\": \\\"{snippet.code}\\\", \\\"user\\\": \\\"{snippet.user}\\\"\\}\"\r\n    }\r\n\r\n    function create_snippet(req) {\r\n    \tbody = HttpRequest.Generic.get_body(req);\r\n    \tp = parser {\r\n    \t\t| s = UriParser.query_element ->\r\n    \t\tmatch (Json.deserialize(s.f2)) {\r\n    \t\tcase {some: {Record: [(_, {String : title}), (_, {String : code}), (_, {String : user})]}} :\r\n    \t\t    snippet = Model.make_snippet(title, code, user);\r\n    \t\t    Model.save_snippet(snippet, function(snippet){\r\n    \t\t\tResource.source(snippet_to_string(snippet), \"application/json\");\r\n    \t\t    });\r\n    \t\tdefault : error(\"error during snippet creation\");\r\n    \t\t};\r\n    \t\t| (.*) -> Resource.source(\"\\{\\\"CREATE SNIPPET\\\":\\\"ERROR\\\"}\", \"application/json\");\r\n    \t};\r\n    \tParser.parse(p, body);\r\n    }\r\n\r\n    function update_snippet(req) {\r\n    \tbody = HttpRequest.Generic.get_body(req);\r\n    \tp = parser {\r\n    \t\t| s = UriParser.query_element ->\r\n    \t\tmatch (Json.deserialize(s.f2)) {\r\n    \t\tcase {some: {Record: [(_, {Int : id}), (_, {String : title}), (_, {String : code}), (_, {String : user})]}} :\r\n    \t\t    snippet = Model.make_snippet(title, code, user);\r\n    \t\t    Model.save_snippet({snippet with id: {some: id}}, function(snippet){\r\n    \t\t\tResource.source(snippet_to_string(snippet), \"application/json\");\r\n    \t\t    });\r\n    \t\tdefault : error(\"error during snippet creation\");\r\n    \t\t};\r\n    \t\t| (.*) -> Resource.source(\"\\{\\\"UPDATE SNIPPER\\\":\\\"ERROR\\\"}\", \"application/json\");\r\n    \t};\r\n    \tParser.parse(p, body);\r\n    }\r\n\r\n    function get_snippet(path) {\r\n    \tp = parser {\r\n    \t\t| s = UriParser.query ->\r\n    \t\tmatch (s) {\r\n    \t\tcase [] -> error(\"error during snippet get\")\r\n    \t\tcase [hd | tl] -> {\r\n    \t\t    match (Json.deserialize(hd.f2)) {\r\n    \t\t    case {some: {Record: [(_, {Int : id})]}}:\r\n    \t\t\tmatch (Model.find_by_id({some: id})) {\r\n    \t\t\tcase {some: snippet} :\r\n    \t\t\t    Resource.source(snippet_to_string(snippet), \"application/json\");\r\n    \t\t\tdefault : error(\"error during snippet get\");\r\n    \t\t\t};\r\n    \t\t    default: error(\"error during snippet get\");\r\n    \t\t    };\r\n    \t\t} }\r\n    \t\t| (.*) -> Resource.source(\"\\{\\\"toto\\\":\\\"POST KO\\\"}\", \"application/json\");\r\n    \t};\r\n    \tParser.parse(p, path);\r\n    }\r\n\r\n    function delete_snippet(req) {\r\n    \tbody = HttpRequest.Generic.get_body(req);\r\n    \tp = parser {\r\n    \t\t| s = UriParser.query_element ->\r\n    \t\tmatch (Json.deserialize(s.f2)) {\r\n    \t\tcase {some: {Record: [(_, {Int : id})]}}:\r\n    \t\t    Model.delete_snippet({some: id}, function(snippet){\r\n    \t\t\tResource.source(snippet_to_string(snippet), \"application/json\");\r\n    \t\t    });\r\n    \t\tdefault: error(\"error during snippet deletion\");\r\n    \t\t};\r\n    \t\t| (.*) -> Resource.source(\"\\{\\\"toto\\\":\\\"POST KO\\\"}\", \"application/json\");\r\n    \t};\r\n    \tParser.parse(p, body);\r\n    }\r\n\r\n    function get_all_snippets() {\r\n        Model.find_all(function(snippets){\r\n    \t    str = List.fold((function(snippet, acc) {\r\n    \t\t\"{acc}{snippet_to_string(snippet)},\"\r\n    \t    }), snippets, \"\");\r\n    \t    str =if (String.length(str) > 1) String.sub(0, (String.length(str) - 1), str) else str;\r\n    \t    Resource.source(\"[{str}]\", \"application/json\");\r\n        });\r\n    }\r\n\r\n    /*  LE SERVEUR AVEC LE GESTIONNAIRE DE REQUETES */\r\n\r\n    dispatcher = parser {\r\n    \t    | \"/\" -> View.simple_main_page()\r\n    \t    | \"/snippets\" -> get_all_snippets();\r\n    \t    | \"/snippet\" path=(.*) -> {\r\n    \t\tmatch (HttpRequest.get_request()) {\r\n    \t\tcase {some: req} :\r\n    \t\t    match (HttpRequest.Generic.get_method(req)) {\r\n    \t\t    case {post}: create_snippet(req);\r\n    \t\t    case {put}: update_snippet(req);\r\n    \t\t    case {get}: get_snippet(Text.to_string(path));\r\n    \t\t    case {delete}: delete_snippet(req);\r\n    \t\t    default: error(\"no method : impossible\");\r\n    \t\t    };\r\n    \t\tcase {none}: error(\"no request : impossible\");\r\n    \t\t}\r\n    \t    }\r\n    \t    | (.*) -> Resource.page(\"Hello\", <><h2>\"404 NOT FOUND!\"</h2></>)\r\n    }\r\n\r\n}\r\n\r\nServer.start(Server.http, {custom : Controller.dispatcher})\r\n```\r\n\r\nCe fichier présente plusieurs concepts clés que nous allons regarder de plus près.\r\n\r\nLa gestion des routes (l'équivalent **Opa** à l'objet **app.routes** de **Express.js** et à la classe **Router** de **Backbone.js**) se fait en **Opa** via un parser d'**URL** : en fonction de l'**URL** reçue on redirige vers des traitements ou des pages spécifiques.\r\n\r\nLa gestion des requêtes de type **REST** se fait ici en récupérant la requête envoyée (grâce à la fonction **HttpRequest.get_request()** de la librairie standard d'**Opa**) et d'effectuer un traitement spécifique en fonction de la méthode employée pour construire la requête. On effectue pour ce faire un *pattern-matching* sur le résultat renvoyé par l'appel à la fonction **HttpRequest.Generic.get_method(req)** qui retourne la méthode associée à la requête courante *req* (celle que l'on est en train de traiter).\r\n\r\nPar exemple, dans le cas de la réception d'une reqête **POST**, la fonction **HttpRequest.Generic.get_method(req)** retourne la valeur ```{post}``` et l'on voit que le *dispatcher* associe à cette valeur la fonction *create_snippet* :\r\n\r\n```case {post}: create_snippet(req);```.\r\n\r\nRegardons plus en détails le code de cette fonction :\r\n\r\n```\r\n    function create_snippet(req) {\r\n    \tbody = HttpRequest.Generic.get_body(req);\r\n    \tp = parser {\r\n    \t\t| s = UriParser.query_element ->\r\n    \t\tmatch (Json.deserialize(s.f2)) {\r\n    \t\tcase {some: {Record: [(_, {String : title}), (_, {String : code}), (_, {String : user})]}} :\r\n    \t\t    snippet = Model.make_snippet(title, code, user);\r\n    \t\t    Model.save_snippet(snippet, function(snippet){\r\n    \t\t\tResource.source(snippet_to_string(snippet), \"application/json\");\r\n    \t\t    });\r\n    \t\tdefault : error(\"error during snippet creation\");\r\n    \t\t};\r\n    \t\t| (.*) -> Resource.source(\"\\{\\\"CREATE SNIPPET\\\":\\\"ERROR\\\"}\", \"application/json\");\r\n    \t};\r\n    \tParser.parse(p, body);\r\n    }\r\n```\r\n\r\nCette fonction prend en paramètre la requête reçue. La première chose à faire est de récupérer le corps de la requête grâce à la fonction **HttpRequest.Generic.get_body**. Une fois ce corps récupéré, il faut le parser pour pouvoir récupérer les éléments constituants la requête. Ces éléments sont codés au format JSON et nous devons donc les décoder pour pouvoir les manipuler en **Opa**. Cela se fait grâce à la focntion **Json.deserialize** :\r\n\r\n```\r\nmatch (Json.deserialize(s.f2)) {\r\n  case {some: {Record: [(_, {String : title}), (_, {String : code}), (_, {String : user})]}} :\r\n```\r\n\r\nNous récupérons alors les données fournies dans la requête : le titre du *snippet*, son code et le nom de l'utilisateur. Nous pouvons donc créer un nouvel *snippet* grâce à ces données et le sauvegarder :\r\n\r\n```\r\nsnippet = Model.make_snippet(title, code, user);\r\nModel.save_snippet(snippet, function(snippet){\r\n  Resource.source(snippet_to_string(snippet), \"application/json\");\r\n});\r\n```\r\n\r\n#### Testons cette application.\r\n\r\nNous avons donc terminé notre petite application, c'est le moment de la tester.\r\nOuvrez un navigateur internet, ouvrez la console JavaScript et entrez les commandes suivantes :\r\n\r\n##### Création de snippet.\r\n\r\n```\r\n$.ajax({\r\n    type: \"POST\",\r\n    url: \"/snippet\",\r\n    data: {\"model\":JSON.stringify({\r\n        title:\"Hello World in Kotlin\",\r\n        code : \"println('Hello world')\",\r\n        user : \"@gregmak\"\r\n    })},\r\n    dataType: 'json',\r\n    error: function () {\r\n        console.log(\"oups\");\r\n    },\r\n    success: function (dataFromServer) {\r\n        console.log(dataFromServer);\r\n    }\r\n});\r\n```\r\n\r\n\r\n\r\n##### Mise à jour de snippet.\r\n\r\n```\r\n$.ajax({\r\n    type: \"PUT\",\r\n    url: \"/snippet\",\r\n    data: {\"model\":JSON.stringify({\r\n        id : 4, /*vérifier que l'id existe*/\r\n        title:\"Hello World in Kotlin\",\r\n        code : \"println('Hello world $name')\",\r\n        user : \"@BOBMORANE\"\r\n    })},\r\n    dataType: 'json',\r\n    error: function () {\r\n        console.log(\"oups\");\r\n    },\r\n    success: function (dataFromServer) {\r\n        console.log(dataFromServer);\r\n    }\r\n});\r\n```\r\n\r\n##### Recherche de snippet.\r\n\r\n```\r\n$.ajax({\r\n    type: \"GET\",\r\n    url: \"/snippet\",\r\n    data: {\"model\":JSON.stringify({id:1})},\r\n    dataType: 'json',\r\n    error: function () {\r\n        console.log(\"oups\");\r\n    },\r\n    success: function (dataFromServer) {\r\n        console.log(dataFromServer);\r\n    }\r\n});\r\n```\r\n\r\n##### Suppression de snippet.\r\n\r\n```\r\n$.ajax({\r\n    type: \"DELETE\",\r\n    url: \"/snippet\",\r\n    data: {\"model\":JSON.stringify({id:1})},\r\n    dataType: 'json',\r\n    error: function () {\r\n        console.log(\"oups\");\r\n    },\r\n    success: function (dataFromServer) {\r\n        console.log(dataFromServer);\r\n    }\r\n});\r\n```\r\n\r\n##### Liste de tous les snippet.\r\n\r\n```\r\n$.ajax({\r\n    type: \"GET\",\r\n    url: \"/snippets\",\r\n    data: null,\r\n    dataType: 'json',\r\n    error: function () {\r\n        console.log(\"oups\");\r\n    },\r\n    success: function (dataFromServer) {\r\n        dataFromServer.forEach(function(model){\r\n            console.log(model)\r\n        });\r\n    }\r\n});\r\n```\r\n\r\n#### Conclusion.\r\n\r\nNous venons de voir comment gérer les requêtes **REST** en **Opa** en comparaison de ce qui est fait par le framework **Express.js**.\r\n\r\nNous verrons dans d'autres tutoriels comment :\r\n- manipuler le **DOM** afin de synchroniser les modèles et les vues associées,\r\n- gérer la persistance via l'utilisation d'une base de données **NoSQL** (en l'occurrence **MongoDB**),\r\n- etc.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Quelques tutoriels"}