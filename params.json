{"google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Quelques tutoriels","body":"Travaillant chez **MLstate**, la compagnie ayant développé le framework JavaScript **Opa** basé sur **Node.js**, j'ai trouvé intéressant de présenter quelques tutoriels et comparatifs avec d'autres frameworks JS.\r\n\r\nLe but de ces tutoriels est de montrer comment **Opa** se compare à d'autres frameworks (tels que **Express.js** ou **Backbone.js**) et quels sont ses avantages que les autres n'ont pas forcément (tels que le typage statique ou encore le *slicing* : découpe automatique du code entre **code client** et **code serveur**).\r\n\r\n## Création d'un web-service **RESTful**.\r\n\r\nLe premier de ces tutoriels portera sur la gestion en **Opa** des requêtes HTTP de type **REST** et permettra de comparer **Opa** avec **Express.js**, framework facilitant le développement de services **RESTful** en JavaScript.\r\n\r\nPour ce faire, nous allons écrire une petite application permettant de traiter des requêtes **REST** telles que **POST**, **PUT**, **DELETE** et **GET** et de manipuler des ressources en conséquence.\r\nCette application est inspirée de celle développée par **k33g_org** et dont vous pouvez voir le tutoriel à l'adresse http://k33g.github.com/2012/02/19/EXPRESSJS_IS_PLAY.html.\r\n\r\n#### Pre-requis.\r\n\r\nVous devez bien sûr installer **Opa**, téléchargeable directement depuis le site d'[opalang](http://opalang.org), ou depuis le [repo github d'opalang](https://github.com/MLstate/opalang).\r\n\r\nUns fois **Opa** téléchargé et installé, vous devriez avoir tout ce dont vous avez besoin. Il n'y a pas d'autres dépendances à installer (**Node.js** étant automatiquement installé par **Opa** s'il n'est pas détecté durant la phase de configuration).\r\n\r\n#### Le squelette de l'application.\r\n\r\n**Opa** est livré avec un outil permettant de générer un squelette d'application basé sur le modèle **MVC**.\r\n\r\nOuvrez une console, placez vous à l'endroit souhaité et tappez simplement\r\n\r\n```opa create snippets```\r\n\r\noù *snippets* est le nom de notre application.\r\n\r\nCela va créer un repertoire *snippets* comprenant le squelette de notre application (pour plus de détails sur cet outil, regardez [l'article de Cédric Soulas sur le blog d'opalang](http://blog.opalang.org/2012/06/programming-tools-ux-how-we-simplified.html)).\r\n\r\n#### La configuration.\r\n\r\nUn fichier nommé ```opa.conf``` est placé à la racine de l'application et décrit les importations nécessaires pour chaque fichier, que ce soit l'importation d'éléments de la librairie standard d'**Opa** ou d'un des autres fichiers source de l'application. Éditez ce fichier et modifier-le comme ceci :\r\n\r\n```javascript\r\nsnippets.controller:\r\n\timport snippets.view\r\n\timport snippets.model // nouvelle ligne ajoutée\r\n\tsrc/controller.opa\r\n\r\nsnippets.view:\r\n\timport snippets.model\r\n\timport stdlib.themes.bootstrap\r\n\tsrc/view.opa\r\n\r\nsnippets.model:\r\n\tsrc/model.opa\r\n```\r\n\r\nEn ajoutant la ligne ```import snippets.model```, nous avons indiqué au compilateur que le module **Controller** du fichier ```src/controller.opa``` a besoin de connaître certaines fonctions définies dans le module **Model** du fichier ```src/model.opa```.\r\n\r\nNotez que ces déclarations peuvent aussi bien se faire en début de chaque fichier. Mais l'utilisation d'un fichier ```opa.conf``` a l'avantage de centraliser toutes les déclarations de ce type.\r\n\r\n#### Le modèle.\r\n\r\nUne fois le squelette créé, nous commençons par modifier le fichier ```src/model.opa``` pour y inclure la définition d'un *snippet* et les traitements associés.\r\n\r\n```javascript\r\ntype Snippet.t = {option(int) id, string title, string code, string user}\r\n\r\nmodule Model {\r\n\r\n    // the user context that will store the list of snippets\r\n    UserContext.t(list(Snippet.t)) snippets = UserContext.make([]);\r\n\r\n    function make_snippet(title, code, user) {\r\n\t{id: {none}, ~title, ~code, ~user}\r\n    }\r\n\r\n    function save_snippet(snippet, callback) {\r\n\tmatch (snippet.id) {\r\n\tcase {some : id}: // existing snippet\r\n\t    UserContext.change((function(snippets) {\r\n\t\tsnippets = List.remove_p((function(snippet) {snippet.id == {some: id}}), snippets);\r\n\t\tList.cons(snippet, snippets);\r\n\t    }), snippets);\r\n\t    // applying the callback onto the given snippet\r\n\t    callback(snippet);\r\n\tdefault: // new snippet\r\n\t    l = UserContext.execute((function(snippets) {List.length(snippets)}), snippets);\r\n\t    id = if (l >= 5) {some : 1} else {some : l + 1}\r\n\t    snippet = {snippet with ~id}\r\n\t    UserContext.change((function(snippets) {\r\n\t\t// the list is reinitiallized every 5 snippets\r\n\t\tif (l >= 5) [snippet]\r\n\t\telse List.cons(snippet, snippets)\r\n\t    }), snippets);\r\n\t    // applying the callback onto the updated snippet\r\n\t    callback(snippet);\r\n\t};\r\n    }\r\n\r\n    function delete_snippet(id, callback) {\r\n\tmatch (find_by_id(id)) {\r\n\tcase {some: snippet} :\r\n\t    UserContext.change((function(snippets) {\r\n\t\tList.remove_p((function(snippet) {snippet.id == id}), snippets);\r\n\t    }), snippets);\r\n\t    // applying the callback onto the found snippet\r\n\t    callback(snippet);\r\n\tdefault : Resource.source(\"\\{\\\"toto\\\":\\\"ERROR\\\"}\", \"application/json\");\r\n\t}\r\n    }\r\n\r\n    function find_all(callback) {\r\n\tUserContext.execute((function(snippets) {\r\n\t    callback(snippets);\r\n\t}), snippets);\r\n    }\r\n\r\n    function find_by_id(id) {\r\n\tUserContext.execute((function(snippets) {\r\n\t    List.find((function(snippet) {snippet.id == id}), snippets);\r\n\t}), snippets);\r\n    }\r\n\r\n}\r\n```\r\n\r\nCe fichier ne présente pas de grandes difficultés si vous êtes familiers avec **Opa** et la programmation fonctionnelle.\r\n\r\nLa seule particularité est l'utilisation du **UserContext**. Ce module, appartenant à la librairie standard d'**Opa**, est un des moyens offerts par **Opa** permettant la création et la manipulation d'éléments mutables.\r\n\r\n#### La vue.\r\n\r\nNous allons maintenant éditer le ficher ```src/view.opa``` pour définir la structure de la page.\r\n\r\n```javascript\r\nmodule View {\r\n\r\n    function initialize() {\r\n\tsnippet_one = Model.make_snippet(\"essai 1\",\"//FOO\",\"gregmak\");\r\n\tsnippet_two = Model.make_snippet(\"essai 2\",\"//Hello World\",\"gregmak\");\r\n\tsnippet_three = Model.make_snippet(\"essai 3\",\"//Me again !\",\"gregmak\");\r\n\r\n\tfunction foo(snippet) {\r\n\t    jlog(snippet.title);\r\n\t};\r\n\r\n\tModel.save_snippet(snippet_one, foo);\r\n\tModel.save_snippet(snippet_two, foo);\r\n\tModel.save_snippet(snippet_three, foo);\r\n    }\r\n\r\n  function simple_main_page() {\r\n      content =\r\n\t<div onready={function(_) {initialize()}}> // on initialise la liste de snippets au chargement de la page\r\n\t</div>;\r\n    Resource.page(\"Hello\", content)\r\n}\r\n```\r\nNotez ici que vous pouvez écrire directement du code HTML dans du code **Opa**. La création de pages web en **Opa** n'etant pas le sujet de ce tutoriel, nous nous contenterons d'une simple page vierge suffisante au bon déroulement de notre application. Il faut juste penser à créer les premiers *snippets* au chargement de la page.\r\n\r\n#### Le contrôleur.\r\n\r\nIl nous reste maintenant à gérer la définition du serveur, le dispatcheur (ou routeur) et le traitements des requêtes **REST**.\r\nCela se fait dans le fichier ```src/controller.opa```, que nous allons éditer et modifier comme cela :\r\n\r\n```javascript\r\nmodule Controller {\r\n\r\n   function save_snippet(snippet) {\r\n    \tModel.save_snippet(snippet, function(snippet){\r\n    \t    Resource.json(OpaSerialize.Json.serialize(snippet));\r\n    \t})\r\n    }\r\n\r\n    function parse_query(callback) {\r\n    \tmatch (HttpRequest.get_body()) {\r\n    \tcase {some : body} -> {\r\n    \t    p = parser {\r\n    \t\t    | s = UriParser.query_element -> {\r\n\t\t\tmatch (s) {\r\n\t\t\tcase (\"model\", model) : callback(model);\r\n\t\t\tdefault : Resource.json({String : \"ERROR DURING REQUEST PARSING\"});\r\n\t\t\t}\r\n\t\t    }\r\n\t\t    | (.*) -> Resource.json({String : \"ERROR DURING REQUEST PARSING\"});\r\n\t    };\r\n\t    Parser.parse(p, body)\r\n\t}\r\n\tdefault : Resource.json({String : \"ERROR DURING REQUEST PARSING\"});\r\n\t}\r\n    }\r\n\r\n    function create_snippet() {\r\n    \tparse_query(function(model) {\r\n    \t    match (OpaSerialize.String.unserialize(model)) {\r\n    \t    case {some: value} :\r\n    \t\tsnippet = Model.make_snippet(value.title, value.code, value.user);\r\n    \t\tsave_snippet(snippet);\r\n    \t    default : error(\"error during snippet creation\");\r\n    \t    }\r\n    \t})\r\n    }\r\n\r\n    function update_snippet() {\r\n    \tparse_query(function(model) {\r\n\t    match (OpaSerialize.partial_unserialize(model)) {\r\n\t    case {some : json} :\r\n    \t\tmatch (OpaSerialize.Json.unserialize_unsorted(json)) {\r\n    \t\tcase {some: snippet} : save_snippet(snippet)\r\n    \t\tdefault : error(\"error during snippet update\");\r\n    \t\t}\r\n\t    default:  error(\"error during snippet update\");\r\n\t    }\r\n\t})\r\n    }\r\n\r\n    function delete_snippet() {\r\n    \tparse_query(function(model) {\r\n    \t    match (OpaSerialize.String.unserialize(model)) {\r\n    \t    case {some: value} :\r\n    \t\tModel.delete_snippet({some: value.id}, function(snippet){\r\n\t\t    Resource.json(OpaSerialize.Json.serialize(snippet));\r\n    \t\t});\r\n    \t    default: error(\"error during snippet deletion\");\r\n    \t    }\r\n\t})\r\n    }\r\n\r\n    function get_snippet(path) {\r\n    \tp = parser {\r\n    \t\t| s = UriParser.query ->\r\n    \t\tmatch (s) {\r\n    \t\tcase [(\"model\", model) | _] -> {\r\n    \t\t    match (Json.deserialize(model)) {\r\n    \t\t    case {some: {Record: [(_, {Int : id})]}}:\r\n    \t\t\tmatch (Model.find_by_id({some: id})) {\r\n    \t\t\tcase {some: snippet} : Resource.json(OpaSerialize.Json.serialize(snippet));\r\n    \t\t\tdefault : error(\"error during snippet get\");\r\n    \t\t\t};\r\n    \t\t    default: error(\"error during snippet get\");\r\n    \t\t    };\r\n    \t\t}\r\n    \t\tdefault -> error(\"error during snippet get\")\r\n\t\t}\r\n    \t\t| (.*) -> Resource.source(\"\\{\\\"toto\\\":\\\"POST KO\\\"}\", \"application/json\");\r\n    \t};\r\n    \tParser.parse(p, path);\r\n    }\r\n\r\n    function get_all_snippets() {\r\n        Model.find_all(function(snippets){\r\n\t    list = List.map((function(snippet) {OpaSerialize.Json.serialize(snippet)}), snippets);\r\n\t    Resource.json({List : list})\r\n\t});\r\n    }\r\n\r\n    /*  LE SERVEUR AVEC LE GESTIONNAIRE DE REQUETES */\r\n\r\n    dispatcher = parser {\r\n    \t    | \"/\" -> View.simple_main_page()\r\n    \t    | \"/snippets\" -> get_all_snippets();\r\n    \t    | \"/snippet\" path=(.*) -> {\r\n    \t\tmatch (HttpRequest.get_method()) {\r\n    \t\tcase {some: {post}}: create_snippet();\r\n    \t\tcase {some: {put}}: update_snippet();\r\n    \t\tcase {some: {get}}: get_snippet(Text.to_string(path));\r\n    \t\tcase {some: {delete}}: delete_snippet();\r\n    \t\tdefault: error(\"error during method inspection\");\r\n    \t\t}\r\n    \t    }\r\n    \t    | (.*) -> Resource.page(\"Hello\", <><h2>\"404 NOT FOUND!\"</h2></>)\r\n    }\r\n\r\n}\r\n\r\nServer.start(Server.http, {custom : Controller.dispatcher})\r\n```\r\n\r\nCe fichier présente plusieurs concepts clés que nous allons regarder de plus près.\r\n\r\n#####Le traitement des requêtes et méthodes HTTP :\r\n\r\nUn serveur **Opa** est associé à un gestionnaire d'URL, ou routes. La gestion des routes se fait via un *parser* d'**URL** : en fonction de l'**URL** reçue on redirige vers des traitements ou des pages spécifiques. C'est  l'équivalent **Opa** de l'objet **app.routes** de **Express.js** et de la classe **Router** de **Backbone.js**. La variable *dispatcher* s'occupe de cela.\r\n\r\n```javascript\r\n    dispatcher = parser {\r\n    \t    | \"/\" -> View.simple_main_page()\r\n    \t    | \"/snippets\" -> get_all_snippets();\r\n    \t    | \"/snippet\" path=(.*) -> {\r\n    \t\tmatch (HttpRequest.get_method()) {\r\n    \t\tcase {some: {post}}: create_snippet();\r\n    \t\tcase {some: {put}}: update_snippet();\r\n    \t\tcase {some: {get}}: get_snippet(Text.to_string(path));\r\n    \t\tcase {some: {delete}}: delete_snippet();\r\n    \t\tdefault: error(\"error during method inspection\");\r\n    \t\t}\r\n    \t    }\r\n    \t    | (.*) -> Resource.page(\"Hello\", <><h2>\"404 NOT FOUND!\"</h2></>)\r\n    }\r\n```\r\n\r\nLa gestion des requêtes de type **REST** se fait ici en récupérant la méthode associée à la requête reçue (grâce à la fonction **HttpRequest.get_method()** de la librairie standard d'**Opa**) et d'effectuer un traitement spécifique en fonction de la méthode employée. On effectue pour ce faire un *pattern-matching* sur le résultat renvoyé : en fonction du résultat retourné, on applique une fonction spécifique.\r\n\r\nPar exemple, dans le cas de la réception d'une requête **POST**, la fonction **HttpRequest.get_method()** retourne la valeur ```{some : {post}}``` et l'on voit que le *dispatcher* associe à cette valeur la fonction **create_snippet** :\r\n\r\n```javascript\r\ncase {some : {post}}: create_snippet();\r\n```\r\n\r\nRegardons plus en détails le code de cette fonction :\r\n\r\n```javascript\r\n    function create_snippet() {\r\n    \tparse_query(function(model) {\r\n    \t    match (OpaSerialize.String.unserialize(model)) {\r\n    \t    case {some: value} :\r\n    \t\tsnippet = Model.make_snippet(value.title, value.code, value.user);\r\n    \t\tsave_snippet(snippet);\r\n    \t    default : error(\"error during snippet creation\");\r\n    \t    }\r\n    \t})\r\n    }\r\n```\r\n\r\nLa fonction **create_snippet** fait un appel à la fonction **parse_query** en lui donnant une fonction de traitement (que nous allons détailler plus loin). Regardons d'abord le corps de la fonction **parse_query** :\r\n\r\n```javascript\r\n    function parse_query(callback) {\r\n    \tmatch (HttpRequest.get_body()) {\r\n    \tcase {some : body} -> {\r\n    \t    p = parser {\r\n    \t\t    | s = UriParser.query_element -> {\r\n\t\t\tmatch (s) {\r\n\t\t\tcase (\"model\", model) : callback(model);\r\n\t\t\tdefault : Resource.json({String : \"ERROR DURING REQUEST PARSING\"});\r\n\t\t\t}\r\n\t\t    }\r\n\t\t    | (.*) -> Resource.json({String : \"ERROR DURING REQUEST PARSING\"});\r\n\t    };\r\n\t    Parser.parse(p, body)\r\n\t}\r\n\tdefault : Resource.json({String : \"ERROR DURING REQUEST PARSING\"});\r\n\t}\r\n    }\r\n```\r\n\r\nNous avons besoin de récupérer le corps de la requête (grâce à la fonction **HttpRequest.get_body()** de la librairie standard d'**Opa**). Une fois ce corps récupéré, il faut l'analyser pour en extraire les éléments constituants la requête, ce qui est fait ici grâce à un *parser* d'**URI**, et enfin appliquer une fonction de traitement (*callback*, donné en paramètre de la fonction) sur ces éléments.\r\n\r\n#####Le traitement des données JSON.\r\n\r\nNous venons de voir comment les éléments constituants la requête avaient été récupérés. Regardons maintenant comment nous pouvons manipuler ces éléments.\r\n\r\nReprenons le code de la fonction **create_snippet** :\r\n\r\n```javascript\r\n    function create_snippet() {\r\n    \tparse_query(function(model) {\r\n    \t    match (OpaSerialize.String.unserialize(model)) {\r\n    \t    case {some: value} :\r\n    \t\tsnippet = Model.make_snippet(value.title, value.code, value.user);\r\n    \t\tsave_snippet(snippet);\r\n    \t    default : error(\"error during snippet creation\");\r\n    \t    }\r\n    \t})\r\n    }\r\n```\r\n\r\nLes éléments constituants la requête sont récupérés sous la forme d'une chaîne de caractères représentant une donnée au format JSON. Nous devons donc décoder cette chaîne de caractères pour récupérer un élément manipulable. Cela est fait par l'appel à la fonction **OpaSerialize.String.unserialize** qui prend en paramètre la chaîne de caractères et retourne un *record* correspondant. Nous pouvons donc maintenant créer un nouveau *snippet* à partir des champs **title**, **code** et **user** du *record* précédemment créé, et le sauvegarder.\r\n\r\nNotez que l'on peut aussi, à partir d'une chaîne de caractères représentant un objet d'un type Opa connu décrit au format JSON, construire directement l'objet correspondant. Cela est par exemple fait dans la fonction **update_snippet** :\r\n\r\n```javascript\r\n    function update_snippet() {\r\n\tparse_query(function(model) {\r\n\t    match (OpaSerialize.partial_unserialize(model)) {\r\n\t    case {some : json} :\r\n    \t\tmatch (OpaSerialize.Json.unserialize_unsorted(json)) {\r\n    \t\tcase {some: snippet} : save_snippet(snippet)\r\n    \t\tdefault : error(\"error during snippet update\");\r\n    \t\t}\r\n\t    default:  error(\"error during snippet update\");\r\n\t    }\r\n\t})\r\n    }\r\n```\r\n\r\nA partir de la chaîne de caractères, on construit un objet de type *RPC.Json.json* grâce à la fonction **OpaSerialize.partial_unserialize**. Il nous reste à décoder cet objet grâce à la fonction **OpaSerialize.Json.unserialize_unsorted** (*unsorted* car les champs dans la requête ne sont pas triés). Nous obtenons alors directement un objet du type *Snippet.t* que nous pouvons donc sauvegarder.\r\n\r\n\r\n\r\n#### Testons cette application.\r\n\r\nNous avons donc terminé notre petite application, c'est le moment de la tester.\r\nOuvrez un navigateur internet, ouvrez la console JavaScript et entrez les commandes suivantes :\r\n\r\n##### Création de snippet.\r\n\r\n```javascript\r\n$.ajax({\r\n    type: \"POST\",\r\n    url: \"/snippet\",\r\n    data: {\"model\":JSON.stringify({\r\n        title:\"Hello World\",\r\n        code : \"println('Hello world')\",\r\n        user : \"@gregmak\"\r\n    })},\r\n    dataType: 'json',\r\n    error: function () {\r\n        console.log(\"oups\");\r\n    },\r\n    success: function (dataFromServer) {\r\n        console.log(dataFromServer);\r\n    }\r\n});\r\n```\r\n\r\n![post.png](https://github.com/gregmak/gregmak.github.com/blob/master/images/v1/post.png?raw=true)\r\n\r\nOn remarque que le serveur nous a renvoyé l'objet créé avec un nouvel *id* associé. Comme nous avions défini 3 *snippets*, le nouveau *snippet* a été créé avec l'*id* 4.\r\n\r\n##### Mise à jour de snippet.\r\n\r\n```javascript\r\n$.ajax({\r\n    type: \"PUT\",\r\n    url: \"/snippet\",\r\n    data: {\"model\":JSON.stringify({\r\n        id : {some : 4}, /*vérifier que l'id existe*/\r\n        title:\"Hello World\",\r\n        code : \"println('Hello world $name')\",\r\n        user : \"@GREGMAK\"\r\n    })},\r\n    dataType: 'json',\r\n    error: function () {\r\n        console.log(\"oups\");\r\n    },\r\n    success: function (dataFromServer) {\r\n        console.log(dataFromServer);\r\n    }\r\n});\r\n```\r\n\r\n![put.png](https://github.com/gregmak/gregmak.github.com/blob/master/images/v1/put.png?raw=true)\r\n\r\nLe serveur nous a renvoyé l'objet avec le champ *user* ayant la nouvelle valeur.\r\n\r\n##### Recherche de snippet.\r\n\r\n```javascript\r\n$.ajax({\r\n    type: \"GET\",\r\n    url: \"/snippet\",\r\n    data: {\"model\":JSON.stringify({id:1})},\r\n    dataType: 'json',\r\n    error: function () {\r\n        console.log(\"oups\");\r\n    },\r\n    success: function (dataFromServer) {\r\n        console.log(dataFromServer);\r\n    }\r\n});\r\n```\r\n\r\n![get.png](https://github.com/gregmak/gregmak.github.com/blob/master/images/v1/get.png?raw=true)\r\n\r\nLe serveur nous a bien renvoyé le *snippet* d'*id* 1.\r\n\r\n##### Suppression de snippet.\r\n\r\n```javascript\r\n$.ajax({\r\n    type: \"DELETE\",\r\n    url: \"/snippet\",\r\n    data: {\"model\":JSON.stringify({id:1})},\r\n    dataType: 'json',\r\n    error: function () {\r\n        console.log(\"oups\");\r\n    },\r\n    success: function (dataFromServer) {\r\n        console.log(dataFromServer);\r\n    }\r\n});\r\n```\r\n\r\n![delete.png](https://github.com/gregmak/gregmak.github.com/blob/master/images/v1/delete.png?raw=true)\r\n\r\n##### Liste de tous les snippet.\r\n\r\n```javascript\r\n$.ajax({\r\n    type: \"GET\",\r\n    url: \"/snippets\",\r\n    data: null,\r\n    dataType: 'json',\r\n    error: function () {\r\n        console.log(\"oups\");\r\n    },\r\n    success: function (dataFromServer) {\r\n        dataFromServer.forEach(function(model){\r\n            console.log(model)\r\n        });\r\n    }\r\n});\r\n```\r\n\r\n![getAll.png](https://github.com/gregmak/gregmak.github.com/blob/master/images/v1/getAll.png?raw=true)\r\n\r\nLe serveur nous a renvoyé une liste de 3 *snippets*, le *snippet* d'*id* 1 ayant été supprimé précédemment.\r\n\r\n#### Conclusion.\r\n\r\nNous venons de voir comment gérer les requêtes **REST** en **Opa** en comparaison de ce qui est fait par le framework **Express.js**.\r\n\r\nNous verrons dans d'autres tutoriels comment :\r\n- manipuler le **DOM** afin de synchroniser les modèles et les vues associées,\r\n- gérer la persistance via l'utilisation d'une base de données **NoSQL** (en l'occurrence **MongoDB**),\r\n- etc.\r\n\r\n\r\n\r\n\r\n## Manipulation du DOM.\r\n\r\nNous allons voir dans ce tutoriel comment manipuler le DOM en **Opa**.\r\nPour ce faire nous allons reprendre l'application ecrite précédamment et nous allons la modifier pour :\r\n\r\n1. permettre à l'utilisateur de créer ses *snippets* via un formulaire plutôt que via des requêtes **REST**\r\n2. que les *snippets* soient affichés dans la page web plutôt que dans la console du navigateur.\r\n\r\nNous avons donc besoin d'une part d'un formulaire et d'autre part d'afficher une liste de *snippets* qui va se mettre à jour au fur et à mesure des créations de *snippets*.\r\n\r\n#### Le modèle.\r\n\r\nLe code du modèle ne change pas.\r\nNous allons donc passer directement à la vue, c'est-à-dire la gestion de l'affichage de la page web.\r\nReportez-vous au précédent tutoriel pour voir le code du modèle.\r\n\r\n#### La vue.\r\n\r\nNous allons maintenant éditer le ficher ```src/view.opa``` pour définir la structure de la page.\r\nCette structure a changé car nous voulons maintenant afficher les *snippets* crées directement dans la page web.\r\n\r\n```javascript\r\nmodule View {\r\n\r\n    function initialize() {\r\n\tsnippet_one = Model.make_snippet(\"essai 1\",\"//FOO\",\"gregmak\");\r\n\tsnippet_two = Model.make_snippet(\"essai 2\",\"//Hello World\",\"gregmak\");\r\n\tsnippet_three = Model.make_snippet(\"essai 3\",\"//Me again !\",\"gregmak\");\r\n\r\n\tfunction foo(snippet) {\r\n\t    display_snippet(snippet);\r\n\t};\r\n\r\n\tModel.save_snippet(snippet_one, foo);\r\n\tModel.save_snippet(snippet_two, foo);\r\n\tModel.save_snippet(snippet_three, foo);\r\n\r\n    }\r\n\r\n    function display_snippet(snippet) {\r\n\tcontent =\r\n\t    <li>\r\n            <h2>{snippet.title} by {snippet.user}</h2><br>\r\n\t    <div>{Markdown.xhtml_of_string({detect_text_links: true}, snippet.code)}</div>\r\n\t    </li>;\r\n\tDom.transform([{jq : #snippet-list, subject : {content : content}, verb : {append}}])\r\n    }\r\n\r\n    function add_snippet() {\r\n\ttitle = Dom.get_value(#title);\r\n\tcode = Dom.get_value(#code)\r\n\tuser = Dom.get_value(#user);\r\n\tif (title == \"\" || code == \"\" || user == \"\") {\r\n\t    message = {alert : {title : \"Error\", description : <> All fields are mandatory. Please fill them all. </>}, closable : true};\r\n\t    alert = WBootstrap.Alert.make(message, {error});\r\n\t    Dom.transform([{jq : #notifications, subject : {content : alert}, verb : {set}}]);\r\n\t} else {\r\n\t    snippet = Model.make_snippet(title, code, user);\r\n\t    Model.save_snippet(snippet, function(snippet) {\r\n\t\tDom.clear_value(#title);\r\n\t\tDom.clear_value(#code);\r\n\t\tDom.clear_value(#user);\r\n\t\tdisplay_snippet(snippet);\r\n\t    });\r\n\t}\r\n    }\r\n\r\n    function simple_main_page() {\r\n\ttitle_bar =\r\n\t    <>\r\n\t    <div class=\"navbar navbar-fixed-top\">\r\n\t    <div class=\"navbar-inner\">\r\n            <div class=\"container\">\r\n            <a class=\"brand\" href=\"#\">\r\n\t    <>OPA</>\r\n\t    </a>\r\n            </div>\r\n\t    </div>\r\n\t    </div>\r\n\t    </>;\r\n\tform =\r\n\t    <>\r\n\t    <div id=\"snippet-form\" style=\"margin-top:50px;\">\r\n            <h2>Go ...</h2>\r\n\t    <form method=\"post\" action=\"javascript:void(0);\" class=\"well\">\r\n            <label>Title : </label>\r\n            <input id=\"title\" type=\"text\" class=\"span3\" placeholder=\"title\"/>\r\n            <label>Code Snippet : (with markdown) </label>\r\n            <textarea id=\"code\" placeholder=\"code\" style=\"width:100%\" rows=\"5\"></textarea>\r\n            <label>User : </label>\r\n            <input id=\"user\" type=\"text\" placeholder=\"user\"/>\r\n            <button type=\"submit\" class=\"btn\" onclick={function(_) {add_snippet()}}>Ajouter un Snippet</button>\r\n\t    </form>\r\n\t    </div>\r\n\t    </>;\r\n\tcontent =\r\n\t    <div onready={function(_) {initialize()}}>\r\n\t    {title_bar}\r\n\t    <div class=\"container\">\r\n\t    <div>{form}</div>\r\n\t    <ul id=\"snippet-list\" style=\"list-style: none;\">\r\n\t    <li data-template>\r\n            <hr>\r\n\t    </li>\r\n\t    </ul>\r\n\t    </div>\r\n\t    <div id=\"notifications\">\r\n\t    </div>\r\n\t    </div>;\r\n\tResource.page(\"StyKKeKode in OPA\", content)\r\n    }\r\n\r\n}\r\n```\r\n\r\n##### La structure de la page.\r\n\r\nNous voyons que la structure de la page est un peu plus complèxe que dans le tutoriel précédent, dans lequel nous nous contentions d'une simple page blanche.\r\nNotre page se compose maintenant d'une barre de titre, d'un formulaire de création de *snippets* et d'un emplacement pour afficherla liste des *snippets*.\r\n\r\nLa barre de titre sert à donner un rendu à la page et permet d'avoir un lien permanent vers une des pages (par exemple la page d'acceuil) de l'application.\r\n\r\nLa création du formulaire ne présente pas de difficultés particulières si vous avez déjà ecrits des formulaires HTML.\r\nIl vous faut préciser la méthode à utiliser pour envoyer les données vers le serveur : **get** ou **post** (ce tutoriel ne portant pas sur les différences entre ces méthodes, je ne les détaillerai pas ici), puis définir les champs qui composeront votre formulaire.\r\nNous avons besoin ici de 3 champs de saisie (pour le titre du *snippet*, le code du *snippet* et le nom de l'utilisateur), ainsi que d'un bouton pour valider le formulaire et envoyer les données au serveur.\r\nLe titre et le nom de l'utilisateur seront renseignés dans deux **input** et le code du *snippet* dans un **textarea**.\r\nAu bouton de soumission est associée la méthode **add_snippet()** qui va lire les données dans les champs du formulaire et les envoyer au serveur pour que celui-ci puisse créer un nouveau *snippet*.\r\n\r\nRegardons le code de cette fonction plus en détails.\r\n\r\n##### La récupération d'informations.\r\n\r\n````javascript\r\n    function add_snippet() {\r\n\ttitle = Dom.get_value(#title);\r\n\tcode = Dom.get_value(#code)\r\n\tuser = Dom.get_value(#user);\r\n\tif (title == \"\" || code == \"\" || user == \"\") {\r\n\t    message = {alert : {title : \"Error\", description : <> All fields are mandatory. Please fill them all. </>}, closable : true};\r\n\t    alert = WBootstrap.Alert.make(message, {error});\r\n\t    Dom.transform([{jq : #notifications, subject : {content : alert}, verb : {set}}]);\r\n\t} else {\r\n\t    snippet = Model.make_snippet(title, code, user);\r\n\t    Model.save_snippet(snippet, function(snippet) {\r\n\t\tDom.clear_value(#title);\r\n\t\tDom.clear_value(#code);\r\n\t\tDom.clear_value(#user);\r\n\t\tdisplay_snippet(snippet);\r\n\t    });\r\n\t}\r\n    }\r\n````\r\n\r\nLa manipulation du DOM se fait en **Opa** via les fonctions du module Dom de la librairie standard.\r\nLa récupération d'informations dans une page web se fait grâce à la méthode **Dom.get_value** qui prend en paramètre un élément de type **dom** et retourne une chaîne de caractères.\r\nDans notre exemple, nous nous servons des identifiants pour récupérer les valeurs qui nous interressent. Ce n'est pas la seule façon de faire\r\n(ni même forcément la meilleure dans le sens où cela neccessite une gestion rigoureuse des identifiants pour éviter toute dupplication).\r\n\r\nPrenons l'exemple du titre du *snipet*.\r\nDans la structure du formulaire nous avons déclaré le champ de saisie ainsi : ```<input id=\"title\" type=\"text\" class=\"span3\" placeholder=\"title\"/>```.\r\nNous lui avons donc associé l'identifiant *title* : ```id=\"title\"```.\r\nNous récupérons le titre entré par l'appel à la fonction Dom.get_value() en lui donnant en paramètre le champ concerné, ici récupéré via son identifiant *title* : ```Dom.get_value(#title)````\r\n(simillairement à JQuery, la syntaxe *#id* fait référence à l'élément d'identifiant *id* contenu dans la page s'il existe).\r\nLes champs récupérés peuvent se manipuler directement, sans traitement particulier, sous forme de chaîne de caractères car ils sont de ce type dans notr définition du type d'un *snippet*.\r\n\r\nUne fois toues les données necessaires récupérées, nous les envoyons au serveur afin qu'il créé un nouveau *snippet*, puis efface les données du formulaire et met à jour la vue pour qu'elle soit synchronisée avec le modèle.\r\n\r\n````javascript\r\n\t    snippet = Model.make_snippet(title, code, user);\r\n\t    Model.save_snippet(snippet, function(snippet) {\r\n\t\tDom.clear_value(#title);\r\n\t\tDom.clear_value(#code);\r\n\t\tDom.clear_value(#user);\r\n\t\tdisplay_snippet(snippet);\r\n\t    });\r\n````\r\n\r\nLa mise à jour de l'affichage de la liste des *snippets* se fait par l'appel à la fonction **dispay_snippet** en lui donnant en paramètre le *sippet* à afficher en plus de ceux déjà affichés.\r\n\r\nRegardons le code de cette fonction plus en détails.\r\n\r\n##### La mise à jour de la vue.\r\n\r\n````javascipt\r\n    function display_snippet(snippet) {\r\n\tcontent =\r\n\t    <li>\r\n            <h2>{snippet.title} by {snippet.user}</h2><br>\r\n\t    <div>{Markdown.xhtml_of_string({detect_text_links: true}, snippet.code)}</div>\r\n\t    </li>;\r\n\tDom.transform([{jq : #snippet-list, subject : {content : content}, verb : {append}}])\r\n    }\r\n````\r\n\r\nLa mise à jour de la vue en fonction du modèle est assez simple.\r\nNous construisons le nouvel élément à insérer puis nous mettons à jour la liste des snippets.\r\n\r\nNous avons défini à la création de notre page un endroit où afficher la liste des *snippets* contenus dans le modèle :\r\n\r\n````javascript\r\n\t    <ul id=\"snippet-list\" style=\"list-style: none;\">\r\n\t    <li data-template>\r\n            <hr>\r\n\t    </li>\r\n\t    </ul>\r\n````\r\n\r\nNous avons juste besoin d'indiquer au DOM que cette liste va contenir un nouvel élément qui est le nouveau snippet. Donc, concrètement, qu'il faut ajouter un nouvel élément *\\<li\\>...\\</li\\>* à l'élément *<ul>...</ul>*.\r\n\r\n````javascript\r\nDom.transform([{jq : #snippet-list, subject : {content : content}, verb : {append}}])\r\n````\r\n\r\nLa fonction **Dom.transform** prend en argument un élément de type **dom** à modifier (que nous récupérons ici grâce à son identifiant *snippet-list*), et la façon de le modifier (cela peut être un ajout à la fin, un ajout au début ou un remplacement).\r\nDans notre exemple nous utilisons la valeur ```{append}``` qui indique que l'on veut ajouter du contenu à la fin.\r\n\r\n##### Gestion d'erreurs.\r\n\r\nNous avons ajouté dans notre exemple un premier niveau de gestion d'erreur.\r\nDans le cas où tous les champs ne sont pas renseignés, un message d'erreur s'affiche sur la page web et aucune données n'est transmise au serveur.\r\nCela permet d'avoir un contrôle sur la structure du formulaire côté client, sans avoir besoin d'envoyer une requête au serveur pour s'appercevoir que des données sont manquantes.\r\nCela ne permet pas en revanche de s'affranchir d'un contrôle plus rigoureux des données côté serveur.\r\n\r\n````javascript\r\n\tif (title == \"\" || code == \"\" || user == \"\") {\r\n\t    message = {alert : {title : \"Error\", description : <> All fields are mandatory. Please fill them all. </>}, closable : true};\r\n\t    alert = WBootstrap.Alert.make(message, {error});\r\n\t    Dom.transform([{jq : #notifications, subject : {content : alert}, verb : {set}}]);\r\n\t}\r\n````\r\n\r\n![snippets_v2_error_server.png](https://github.com/gregmak/gregmak.github.com/blob/master/images/v2/snippets_v2_error_server.png?raw=true)\r\n\r\n#### Le controlleur.\r\n\r\nDans cette version le code du controlleur est beaucoup plus simple et court car nous n'avons plus besoin des traiter des requêtes **REST**.\r\nUn simple parser d'URL permet de faire tourner notre application (nous n'avons qu'une page à servir).\r\n\r\n````javascript\r\nmodule Controller {\r\n\r\n    dispatcher = parser {\r\n    \t    | \"/\" -> View.simple_main_page()\r\n    \t    | (.*) -> Resource.page(\"Hello\", <><h2>\"404 NOT FOUND!\"</h2></>)\r\n    }\r\n\r\n}\r\n\r\nServer.start(Server.http, {custom : Controller.dispatcher})\r\n````\r\n\r\n#### Testons cette application.\r\n\r\nUne fois l'application compilée et lancée, ouvrez votre navigateur à l'adresse indiquée.\r\nVous voyez que la page affiche déjà les 3 *snippets* qu'on a créé au lancement du serveur. Le modèle et la vue sont donc bien synchronisés au démarrage du serveur.\r\n\r\n![snippets_v2_1.png](https://github.com/gregmak/gregmak.github.com/blob/master/images/v2/snippets_v2_1.png?raw=true)\r\n\r\nEntrez un titre et un code pour votre *sinppet*, votre nom et cliquez sur le bouton 'Ajouter un snippet'.\r\n\r\n![snippets_v2_2.png](https://github.com/gregmak/gregmak.github.com/blob/master/images/v2/snippets_v2_2.png?raw=true)\r\n\r\nVous voyez que la vue a bien été mise à jour avec votre nouveau snippet affiché en fin de liste.\r\n\r\n![snippets_v2_3.png](https://github.com/gregmak/gregmak.github.com/blob/master/images/v2/snippets_v2_3.png?raw=true)\r\n\r\n#### Conclusion.\r\n\r\nNous venons de voir comment manipuler le DOM en **Opa** en comparaison de ce qui est fait par le framework **Backbone.js**.\r\n\r\nNous verrons dans d'autres tutoriels comment :\r\n- gérer la persistance via l'utilisation d'une base de données **NoSQL** (en l'occurrence **MongoDB**),\r\n- etc.\r\n\r\n\r\n\r\n\r\n## Persistance avec MongoDB.\r\n\r\nNous allons voir dans ce tutoriel comment gérer la persistance en **Opa** via l'utilisation d'une base de données NoSQL : **MongoDB**.\r\nPour ce faire nous allons reprendre l'application ecrite précédamment et nous allons la modifier pour que les *snippets* créés soient stockés dans une base de données plutôt qu'en RAM.\r\n\r\n#### Le modèle.\r\n\r\nCette fois le code du modèle va changer par rapport à la première version de l'application.\r\nNous y déclarons maintenant notre base de données, ainsi que toutes les fonctions de manipulation de *snippets*.\r\n\r\n```javascript\r\ntype Snippet.t = {option(int) id, string title, string code, string user}\r\n\r\ndatabase test {\r\n    Snippet.t /snippets[{id}] // the set of snippets\r\n}\r\n\r\nmodule Model {\r\n\r\n    function make_snippet(title, code, user) {\r\n\t{id: {none}, ~title, ~code, ~user}\r\n    }\r\n\r\n    function save_snippet(snippet, callback) {\r\n\tmatch (snippet.id) {\r\n\tcase {some : _}:\r\n\t\t/test/snippets[{id : snippet.id}] <- snippet;\r\n\t    // applying the callback onto the given snippet\r\n\t    callback(snippet);\r\n\tdefault: // new snippet\r\n\t    size = Iter.count(DbSet.iterator(/test/snippets));\r\n\t    id = {some : size + 1};\r\n\t    snippet = {snippet with ~id};\r\n\t\t/test/snippets[{id: id}] <- snippet;\r\n\t    // applying the callback onto the updated snippet\r\n\t    callback(snippet);\r\n\t}\r\n    }\r\n\r\n    function find_all(callback) {\r\n\tit = DbSet.iterator(/test/snippets);\r\n\tsnippets = Iter.to_list(it);\r\n\tcallback(snippets);\r\n    }\r\n\r\n    function find_by_id(id) {\r\n\t    /test/snippets[{id: {some: id}}];\r\n    }\r\n\r\n    function delete_snippet(id, callback) {\r\n\tsnippet = find_by_id(id);\r\n\tDb.remove(@/test/snippets[{id: snippet.id}]);\r\n\t// applying the callback onto the found snippet\r\n\tcallback(snippet);\r\n    }\r\n\r\n    function initialize(callback) {\r\n\tfunction callback(snippet) {\r\n\t    callback(snippet, {append});\r\n\t}\r\n\tfind_all(function(snippets) {\r\n\t    if (List.is_empty(snippets)) {\r\n\t\tsnippet_one = make_snippet(\"essai 1\",\"//FOO\",\"gregmak\");\r\n\t\tsnippet_two = make_snippet(\"essai 2\",\"//Hello World\",\"gregmak\");\r\n\t\tsnippet_three = make_snippet(\"essai 3\",\"//Me again !\",\"gregmak\");\r\n\t\tsave_snippet(snippet_one, callback);\r\n\t\tsave_snippet(snippet_two, callback);\r\n\t\tsave_snippet(snippet_three, callback);\r\n\t    } else {\r\n\t\tList.iter(function(snippet) {\r\n\t\t    callback(snippet);\r\n\t\t}, snippets)\r\n\t    }\r\n\t})\r\n    }\r\n\r\n}\r\n\r\n````\r\n\r\nCe code commence avec la déclaration du type d'un *snippet*. Nous voyons qu'ici un *snippet* est composé d'un identifiant, d'un titre, d'un code et d'un nom pour le créateur.\r\n\r\n```javascript\r\ntype Snippet.t = {option(int) id, string title, string code, string user}\r\n```\r\n\r\nTous ces champs sauf l'identifiant sont des chaînes de caractères. L'identifiant est un entier optionel (c'est-à-dire qu'il peut ne pas être précisé).\r\n\r\nUns fois le(s) type(s) de données définis, nous devons déclarer la structure de notre base de données.\r\n\r\n````javascript\r\ndatabase test {\r\n    Snippet.t /snippets[{id}] // the set of snippets\r\n}\r\n````\r\n\r\nNous venons de déclarer une base de données ayant pour nom *test* et ayant un seul chemin : */snippets[{id}]* servant à stocker des données du type *Snippet.t*.\r\nIci nous n'avons que des *snippets* à stocker, notre base peut dont se composer d'un chemin unique.\r\nCette déclaration indique que l'on veut stocker un *set* de *snippets* avec le champ *id* comme clé primaire.\r\nCes *snippets* seront donc récupérés dans la base de donneés par leur identifiant.\r\n\r\nRegardons plus en détail les fonctions de manipulation des *snippets*.\r\n\r\n##### La recherche de *snippets*.\r\n\r\nNous définissons ici une méthode pour récupérer tous les *snippets* contenus dans la base et une méthode pour récupérer un *snippet* à partir de son identifiant.\r\n\r\n````javascript\r\n    function find_all(callback) {\r\n\tit = DbSet.iterator(/test/snippets);\r\n\tsnippets = Iter.to_list(it);\r\n\tcallback(snippets);\r\n    }\r\n\r\n    function find_by_id(id) {\r\n\t    /test/snippets[{id: {some: id}}];\r\n    }\r\n````\r\n\r\nCes deux fonctions prennent en argument une continuation à appliquer unefois le ou les *snippet(s)* récupéré(s).\r\n\r\nLa méthode pour récupérer tous les *snippets* va lire l'ensmble des *snippets* sur le chemin */test/snippets* sous la forme d'un *DbSet*.\r\nNous voulons manipuler ces *sniipets* sous forme de liste donc nous transformons notre *DbSet* en liste de *snippets* en passant par un *iterator*.\r\n\r\nLa méthode pour récupérer un *snippet* particulier prend en plus l'identifiant du *snippet* rechercher.\r\nCette méthode va chercher dans l'ensemble des *snippets* et applique la continuation sur le *snippet* ayant l'identifiant recherché.\r\n\r\n###### Attention !!!\r\n\r\nChaque chemin d'une déclaration de base de données est associée à une valeur par défaut.\r\nSi aucune donnée n'est sotckée au chemin indiqué, la valeur par défaut associée à ce chemin sera retournée.\r\nC'est pourquoi une lecture sur un chemin valide de la base de donneés retourne toujours un résultat.\r\nC'est au programeur de faire attention, en manipulant le résultat retourner, à savoir s'il manipule cette valeur par défaut ou une valeur trouvée dans la base de données.\r\nNous reverrons ce point plus loin dans la partie sur la gestion de la vue.\r\n\r\n##### La sauvegarde de *snippets*.\r\n\r\n````javascript\r\n    function save_snippet(snippet, callback) {\r\n\tmatch (snippet.id) {\r\n\tcase {some : _}:\r\n\t\t/test/snippets[{id : snippet.id}] <- snippet;\r\n\t    // applying the callback onto the given snippet\r\n\t    callback(snippet);\r\n\tdefault: // new snippet\r\n\t    size = Iter.count(DbSet.iterator(/test/snippets));\r\n\t    id = {some : size + 1};\r\n\t    snippet = {snippet with ~id};\r\n\t\t/test/snippets[{id: id}] <- snippet;\r\n\t    // applying the callback onto the updated snippet\r\n\t    callback(snippet);\r\n\t}\r\n    }\r\n````\r\n\r\nComme nous l'avons indiqué précédamment, les *snippets* seront enregistrés dans la base de données avec leur identifiant comme clé primaire.\r\nL'identifiant d'un *snippet* est un entier optionel (c'est-à-dire qu'il peut ne pas être rensigné comme c'est le cas à la création d'un nouveau *snippet*).\r\nNous devons donc traiter les deux cas lors de l'enregistrement d'un *snippet* :\r\n\r\n1. Le cas où l'identifiant est rensigné (donc enregistrement d'un *snippet* existant).\r\n2. Le cas où il n'est pas rensigné (donc enregistrement d'un nouveau *snippet*).\r\n\r\nNous effectuons donc un *pattern-matching* sur l'identifiant du *snippet* à sauvegarder.\r\n\r\nDans le cas où l'identifiant est renseigné, nous avons juste à écraser l'ancien *snippet* par le nouveau.\r\n\r\nDans le cas où l'identifiant n'est pas connu, nous devons en créér un nouveau et l'assigner au *snippet* à sauvegarder.\r\nPour ce faire nous avons besoin de connaitre le nombre de *snippets* actuellement contenu dans la base de données. Nous passons encore une fois par un *iterator*.\r\n\r\n````javascript\r\n\t    size = Iter.count(DbSet.iterator(/test/snippets));\r\n````\r\n\r\nUne fois le nombre de *snippets* connus, nous pouvons créér notre nouvel identifiant en prennant l'entier suivant ce nombre et ainsi nous assurer que chaque *snippet* contenu dans la base aura bien un identifiant unique.\r\n\r\n````javascript\r\n\t    id = {some : size + 1};\r\n````\r\n\r\nIl ne nous reste plus qu'a assigner ce nouvel identifiant à notre nouveau *snippet* et l'enregistrer dans la base avec cet identifiant comme clé primaire, puis appliquer la continuation.\r\n\r\n````javascript\r\n\tsnippet = {snippet with ~id};\r\n\t/test/snippets[{id: id}] <- snippet;\r\n\tcallback(snippet);\r\n````\r\n\r\n##### La suppression de *snippets*.\r\n\r\n````javascript\r\n    function delete_snippet(id, callback) {\r\n\tif (Db.exists(@/test/snippets[{id: {some: id}}])) {\r\n\t    Db.remove(@/test/snippets[{id: {some: id}}]);\r\n\t    callback({ok});\r\n\t} else {\r\n\t    callback({ko});\r\n\t}\r\n    }\r\n````\r\n\r\nLa suppression d'un *snippet* n'est pas très compliquée.\r\nNous testons l'existence du *snippet* ayant l'identifiant donné. S'il existe, nous le supprimons et indiquons que la suppression a été faite (````callback({ok})````). Sinon, nous indiquons que la suppression ne s'est pas faire (````callback({ko})````).\r\n\r\n#####L'initialisation.\r\n\r\nAu démarrage de notre serveur, nous regardons le contenu de notre base de données par un appel à la fonction *find_all()*.\r\nSi la liste retournée est vide, nous créons trois *snippets* pour remplir la base et nous les affichons.\r\nDans le cas contraire, la base est déjà remplie de quelques *snippets* que nous affichons.\r\n\r\n````javascript\r\n    function initialize(callback) {\r\n\tfunction callback(snippet) {\r\n\t    callback(snippet, {append});\r\n\t}\r\n\tfind_all(function(snippets) {\r\n\t    if (List.is_empty(snippets)) {\r\n\t\tsnippet_one = make_snippet(\"essai 1\",\"//FOO\",\"gregmak\");\r\n\t\tsnippet_two = make_snippet(\"essai 2\",\"//Hello World\",\"gregmak\");\r\n\t\tsnippet_three = make_snippet(\"essai 3\",\"//Me again !\",\"gregmak\");\r\n\t\tsave_snippet(snippet_one, callback);\r\n\t\tsave_snippet(snippet_two, callback);\r\n\t\tsave_snippet(snippet_three, callback);\r\n\t    } else {\r\n\t\tList.iter(function(snippet) {\r\n\t\t    callback(snippet);\r\n\t\t}, snippets)\r\n\t    }\r\n\t})\r\n    }\r\n````\r\n\r\n#### La vue.\r\n\r\n````javascript\r\nmodule View {\r\n\r\n    function initialize() {\r\n\tModel.initialize(display_snippet);\r\n    }\r\n\r\n    function display_snippet(snippet, verb) {\r\n\tcontent =\r\n\t    <li>\r\n            <h2>{snippet.title} by {snippet.user}</h2><br>\r\n\t    <div>{Xhtml.of_string_unsafe(snippet.code)}</div>\r\n\t    </li>;\r\n\tDom.transform([{jq : #snippet-list, subject : {content : content}, ~verb}])\r\n    }\r\n\r\n    function add_snippet() {\r\n\ttitle = Dom.get_value(#title);\r\n\tcode = Dom.get_value(#code)\r\n\t    |> Markdown.xhtml_of_string({detect_text_links: true}, _)\r\n\t    |> Xhtml.to_string(_);\r\n\tuser = Dom.get_value(#user);\r\n\tif (title == \"\" || code == \"\" || user == \"\") {\r\n\t    message = {alert : {title : \"Erreur\", description : <> All fields are mandatory. Please fill them all. </>}, closable : true};\r\n\t    alert = WBootstrap.Alert.make(message, {error});\r\n\t    Dom.transform([{jq : #notifications, subject : {content : alert}, verb : {set}}]);\r\n\t} else {\r\n\t    snippet = Model.make_snippet(title, code, user);\r\n\t    Model.save_snippet(snippet, function(snippet) {\r\n\t\tDom.clear_value(#title);\r\n\t\tDom.clear_value(#code);\r\n\t\tDom.clear_value(#user);\r\n\t\tdisplay_snippet(snippet, {append});\r\n\t    });\r\n\t}\r\n    }\r\n\r\n    function show_all() {\r\n\tModel.find_all(function(snippets) {\r\n\t    List.iteri(function(i, snippet) {\r\n\t\tif (i == 0) {\r\n\t\t    display_snippet(snippet, {set});\r\n\t\t} else {\r\n\t\t    display_snippet(snippet, {append});\r\n\t\t}\r\n\t    }, snippets)\r\n\t})\r\n    }\r\n\r\n    function show_snippet() {\r\n\tid = Dom.get_value(#snippet_id_show) |> Int.of_string(_)\r\n\tsnippet = Model.find_by_id(id);\r\n\tif (snippet.title == \"\") {\r\n\t    message = {alert : {title : \"Error\", description : <> Snippet of id {id} does not exist. </>}, closable : true};\r\n\t    alert = WBootstrap.Alert.make(message, {success});\r\n\t    Dom.transform([{jq : #notifications, subject : {content : alert}, verb : {set}}]);\r\n\t    Dom.clear_value(#snippet_id_show);\r\n\t} else {\r\n\t    display_snippet(snippet, {set});\r\n\t    Dom.clear_value(#snippet_id_show);\r\n\t}\r\n    }\r\n\r\n    function delete_snippet() {\r\n\tid = Dom.get_value(#snippet_id_delete) |> Int.of_string(_)\r\n\tModel.delete_snippet(id, function(result) {\r\n\t    match (result) {\r\n\t    case {ok} :\r\n\t\tmessage = {alert : {title : \"OK\", description : <> Snippet of id {id} has been removed. </>}, closable : true};\r\n\t\talert = WBootstrap.Alert.make(message, {success});\r\n\t\tDom.transform([{jq : #notifications, subject : {content : alert}, verb : {set}}]);\r\n\t\tDom.clear_value(#snippet_id_delete);\r\n\t    case {ko} :\r\n\t\tmessage = {alert : {title : \"Error\", description : <> Snippet of id {id} does not exist. </>}, closable : true};\r\n\t\talert = WBootstrap.Alert.make(message, {success});\r\n\t\tDom.transform([{jq : #notifications, subject : {content : alert}, verb : {set}}]);\r\n\t\tDom.clear_value(#snippet_id_delete);\r\n\t    }\r\n\t})\r\n    }\r\n\r\n    function simple_main_page() {\r\n\ttitle_bar =\r\n\t    <>\r\n\t    <div class=\"navbar navbar-fixed-top\">\r\n\t    <div class=\"navbar-inner\">\r\n            <div class=\"container\">\r\n            <a class=\"brand\" href=\"#\">\r\n\t    <>OPA</>\r\n\t    </a>\r\n            </div>\r\n\t    </div>\r\n\t    </div>\r\n\t    </>;\r\n\tform =\r\n\t    <>\r\n\t    <div id=\"snippet-form\" style=\"margin-top:50px;\">\r\n            <h2>Go ...</h2>\r\n\t    <form method=\"post\" action=\"javascript:void(0);\" class=\"well\">\r\n            <label>Title : </label>\r\n            <input id=\"title\" type=\"text\" class=\"span3\" placeholder=\"title\"/>\r\n            <label>Code Snippet : (with markdown) </label>\r\n            <textarea id=\"code\" placeholder=\"code\" rows=\"5\"></textarea>\r\n            <label>User : </label>\r\n            <input id=\"user\" type=\"text\" placeholder=\"user\"/>\r\n            <button type=\"submit\" class=\"btn\" onclick={function(_) {add_snippet()}}>Add a Snippet</button>\r\n\t    </form>\r\n\t    </div>\r\n\t    </>;\r\n\tboutons =\r\n\t    <>\r\n\t    <div><button type=\"submit\"  class=\"btn\" onclick={function(_) {show_all()}}>Show all snippets</button></div>\r\n\t    <div>\r\n\t    <button type=\"submit\"  class=\"btn\" onclick={function(_) {show_snippet()}}>Show snippet of id</button>\r\n\t    <input id=\"snippet_id_show\" class=\"snippet-id\" type=\"text\" placeholder=\"id\"/>\r\n\t    </div>\r\n\t    <div>\r\n\t    <button type=\"submit\"  class=\"btn\" onclick={function(_) {delete_snippet()}}>Delete snippet of id</button>\r\n\t    <input id=\"snippet_id_delete\" class=\"snippet-id\" type=\"text\" placeholder=\"id\"/>\r\n\t    </div>\r\n\t    </>;\r\n\tcontent =\r\n\t    <div onready={function(_) {initialize()}}>\r\n\t    {title_bar}\r\n\t    <div class=\"container\">\r\n\t    <div>{form}</div>\r\n\t    <div>{boutons}</div>\r\n\t    <ul id=\"snippet-list\" style=\"list-style: none;\">\r\n\t    <li data-template>\r\n            <hr>\r\n\t    </li>\r\n\t    </ul>\r\n\t    </div>\r\n\t    <div id=\"notifications\">\r\n\t    </div>\r\n\t    </div>;\r\n\tResource.page(\"StyKKeKode in OPA\", content)\r\n    }\r\n\r\n}\r\n````\r\n\r\nLa vue ne change pas énormément comparé à la version précédente sur la manipulation du DOM en *Opa*.\r\nElle comporte quelques fonctions suplémentaires que vous allons détailler maintenant.\r\n\r\n#####Affichage de tous les *snippets*.\r\n\r\n````javascript\r\n    function show_all() {\r\n\tModel.find_all(function(snippets) {\r\n\t    List.iteri(function(i, snippet) {\r\n\t\tif (i == 0) {\r\n\t\t    display_snippet(snippet, {set});\r\n\t\t} else {\r\n\t\t    display_snippet(snippet, {append});\r\n\t\t}\r\n\t    }, snippets)\r\n\t})\r\n    }\r\n````\r\n\r\nNous récupérons la liste de tous les *snippets* contenus dans la base par un appel à la fonction *find_all()* et pour chaque *snippet* contenu dans la liste nous appelons la fonction d'affichage *display_snippet()*.\r\nPour le 1er *snippet* à afficher nous passons la valeur {set} à la fonction *display_snippet()* pour lui indiquer que cet affichage doit écraser l'affichage précédent.\r\nPar la suite nous utilisont la valeur {append} pour indiquer que les affichages suivants viendront s'ajouter au premier.\r\n\r\n#####Affichage d'un *snippet*.\r\n\r\n````javascript\r\n    function show_snippet() {\r\n\tid = Dom.get_value(#snippet_id_show) |> Int.of_string(_)\r\n\tsnippet = Model.find_by_id(id);\r\n\tif (snippet.title == \"\") {\r\n\t    message = {alert : {title : \"Error\", description : <> Snippet of id {id} does not exist. </>}, closable : true};\r\n\t    alert = WBootstrap.Alert.make(message, {success});\r\n\t    Dom.transform([{jq : #notifications, subject : {content : alert}, verb : {set}}]);\r\n\t    Dom.clear_value(#snippet_id_show);\r\n\t} else {\r\n\t    display_snippet(snippet, {set});\r\n\t    Dom.clear_value(#snippet_id_show);\r\n\t}\r\n    }\r\n````\r\n\r\nPour afficher un *snippet* particulier, nous avons besoin de lire son identifiant renseigné par l'utilisateur dans le champ *snippet_id_show* (veuillez vous reporter au tutoriel sur la manipulation du DOM en *Opa* pour plus de détails sur ce sujet).\r\nUne fois cet identifiant récupéré, nous appelons la fonction *find_by_id()* du modèle et nous appliquons un traitement particulier en fonction de la valeur retournée.\r\n\r\nNous avons précisé précédamment qu'une lecture sur un chemin de la base de données retournait toujours un résultat. Si aucune donnée ne se trouve sur un chemin donné, la valeur par défaut associée à ce chemin est retournée.\r\nNous devons donc regarder le conteunu de la valeur retournée pour nous assurer que ce n'est pas la valeur par défaut, mais bien un *snippet* trouvé sur le chemin donné.\r\nNous faisons le test ici uniquement sur le titre du *snippet* retourné pour nous assurer qu'il n'est pas vide, ce qui serait le cas pour la valeur par défaut.\r\nSi le titre du *snippet* n'est pas vide, nous appelons la fonction d'affichage *display_snippet()* avec en paramètres le *snippet* retourné et la valeur {set} pour écraser l'affichage précédent :\r\n\r\n````javascript\r\n\t    display_snippet(snippet, {set});\r\n````\r\n\r\nSi le titre du *snippet* est vide, nous affichons un message d'erreur pour indiquer à l'utilisateur que le *snippet* recherché n'a pas été trouvé.\r\n\r\n````javascript\r\n\t    message = {alert : {title : \"Error\", description : <> Snippet of id {id} does not exist. </>}, closable : true};\r\n\t    alert = WBootstrap.Alert.make(message, {success});\r\n\t    Dom.transform([{jq : #notifications, subject : {content : alert}, verb : {set}}]);\r\n````\r\n\r\nDans tous les cas, nous nettoyns le formulaire de la valeur lue dans le champ *snippet_id_show* :\r\n\r\n````javascript\r\n\t    Dom.clear_value(#snippet_id_show);\r\n````\r\n\r\n#####Suppression d'un *snippet*.\r\n\r\n````javascript\r\n    function delete_snippet() {\r\n\tid = Dom.get_value(#snippet_id_delete) |> Int.of_string(_)\r\n\tModel.delete_snippet(id, function(result) {\r\n\t    match (result) {\r\n\t    case {ok} :\r\n\t\tmessage = {alert : {title : \"OK\", description : <> Snippet of id {id} has been removed. </>}, closable : true};\r\n\t\talert = WBootstrap.Alert.make(message, {success});\r\n\t\tDom.transform([{jq : #notifications, subject : {content : alert}, verb : {set}}]);\r\n\t\tDom.clear_value(#snippet_id_delete);\r\n\t    case {ko} :\r\n\t\tmessage = {alert : {title : \"Error\", description : <> Snippet of id {id} does not exist. </>}, closable : true};\r\n\t\talert = WBootstrap.Alert.make(message, {success});\r\n\t\tDom.transform([{jq : #notifications, subject : {content : alert}, verb : {set}}]);\r\n\t\tDom.clear_value(#snippet_id_delete);\r\n\t    }\r\n\t})\r\n    }\r\n````\r\n\r\n#### Le controlleur.\r\n\r\n````javascript\r\nmodule Controller {\r\n\r\n    dispatcher = parser {\r\n    \t    | \"/\" -> View.simple_main_page()\r\n    \t    | (.*) -> Resource.page(\"Hello\", <><h2>\"404 NOT FOUND!\"</h2></>)\r\n    }\r\n\r\n}\r\n\r\nresources = @static_resource_directory(\"resources\")\r\n\r\nServer.start(Server.http, [\r\n  { register:\r\n    [ { doctype: { html5 } },\r\n      { js: [ ] },\r\n      { css: [ \"/resources/css/style.css\"] }\r\n    ]\r\n  },\r\n  { ~resources },\r\n  { custom: Controller.dispatcher }\r\n])\r\n\r\n````\r\nLe code du controlleur ressemble fortement à celui de la précédente version. Nous lui ajoutons juste le chargement du fichier .css dans lequel nous avons défini le style pour quelques éléments de notre page.\r\n\r\n#### Testons cette application.\r\n\r\nUne fois l'application compliée et lancée, ouvrez votre navigateur à l'adresse ````localhost:8080```` qui est l'adresse par défaut.\r\nVous voyez que la page affiche déjà les 3 *snippets* que nous avons crées au démarrage du serveur.\r\n\r\n![snippets_v2_error_server_2.png](https://github.com/gregmak/gregmak.github.com/blob/master/images/v3/snippets_v3_1.png?raw=true)\r\n\r\nNous créeons un nouveau snippet.\r\n\r\n![snippets_v2_error_server_2.png](https://github.com/gregmak/gregmak.github.com/blob/master/images/v3/snippets_v3_2.png?raw=true)\r\n\r\nLa page affiche bien maintenant les 4 contenus dans la base.\r\n\r\n![snippets_v2_error_server_2.png](https://github.com/gregmak/gregmak.github.com/blob/master/images/v3/snippets_v3_3.png?raw=true)\r\n\r\nTestons maintent l'affichage d'un *snippet* en particulier.\r\nEntrez la valeur \"3\" dans le champ de saisie à droite du bouton 'Show snippet of id', puis validez en cliquant sur le bouton ou en appuyant sur la toûche 'Entrée'.\r\n\r\n![snippets_v2_error_server_2.png](https://github.com/gregmak/gregmak.github.com/blob/master/images/v3/snippets_v3_4.png?raw=true)\r\n\r\nNous voyons que seul le *snippet* d'identifiant \"3\" est affiché.\r\n\r\nTestons maintenant la suppression d'un *snippet*.\r\nEntrez la valeur \"4\" dans le champ de saisie à droite du bouton 'Delete snippet of id', puis validez en cliquant sur le bouton ou en appuyant sur la toûche 'Entrée'.\r\n\r\n![snippets_v2_error_server_2.png](https://github.com/gregmak/gregmak.github.com/blob/master/images/v3/snippets_v3_5.png?raw=true)\r\n\r\nVérifions que la suppression a bien été éfféctuée.\r\nDemandons l'affichage du *snippet* d'identifiant \"4\", soit celui que nous venons de supprimer.\r\nEntrez la valeur \"4\" dans le champ de saisie à droite du bouton 'Show snippet of id', puis validez en cliquant sur le bouton ou en appuyant sur la toûche 'Entrée'.\r\n\r\n![snippets_v2_error_server_2.png](https://github.com/gregmak/gregmak.github.com/blob/master/images/v3/snippets_v3_6.png?raw=true)\r\n\r\nNous voyons que le système nous préviens que le *snippet* recherché n'existe pas.\r\n\r\nDemandons maintenant l'affichage de tous les *snippets* contenus dans la base.\r\nCliquez sur le bouton 'Show all snippets'.\r\n\r\n![snippets_v2_error_server_2.png](https://github.com/gregmak/gregmak.github.com/blob/master/images/v3/snippets_v3_7.png?raw=true)\r\n\r\nNous voyons bien que seulement 3 *snippets* sont affichés. Le *snippet* d'identifiant \"4\" a bien été supprimé de la base de données.\r\n\r\n\r\n#### Conclusion.\r\n\r\nNous venons de voir comment gérer la persistance via l'utilisation d'une base de données **NoSQL** (en l'occurrence **MongoDB**).","name":"Gregmak.github.com"}